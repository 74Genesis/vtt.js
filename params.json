{"name":"vtt.js","tagline":"A JavaScript implementation of the WebVTT specification","body":"vtt.js\r\n======\r\n\r\n[![Build Status](https://travis-ci.org/mozilla/vtt.js.svg?branch=master)](https://travis-ci.org/mozilla/vtt.js) [![npm-version](http://img.shields.io/npm/v/vtt.js.svg)](https://www.npmjs.org/package/vtt.js) [![Dependency Status](https://david-dm.org/mozilla/vtt.js.svg?theme=shields.io)](https://david-dm.org/mozilla/vtt.js) [![devDependency Status](https://david-dm.org/mozilla/vtt.js/dev-status.svg?theme=shields.io)](https://david-dm.org/mozilla/vtt.js#info=devDependencies)\r\n\r\nImplementation of the [WebVTT](https://developer.mozilla.org/en-US/docs/HTML/WebVTT) spec in JavaScript. Can be used\r\nin NodeJS, on the browser, and many other places. Mozilla uses this implementation for parsing and processing WebVTT\r\nfiles in Firefox/Gecko.\r\n\r\n##Table of Contents##\r\n\r\n- [Spec Compliance](#spec-compliance)\r\n- [API](#api)\r\n  - [WebVTT.Parser](#webvttparser)\r\n    - [parse(data)](#parsedata)\r\n    - [flush()](#flush)\r\n    - [onregion(region)](#onregionregion)\r\n    - [oncue(cue)](#oncuecue)\r\n    - [onflush()](#onflush)\r\n    - [onparsingerror(error)](#onparsingerrorerror)\r\n  - [WebVTT.convertCueToDOMTree(window, cuetext)](#webvttconvertcuetodomtreewindow-cuetext)\r\n  - [WebVTT.processCues(window, cues, overlay)](#webvttprocesscueswindow-cues-overlay)\r\n  - [ParsingError](#parsingerror)\r\n  - [VTTCue](#vttcue)\r\n    - [Extended API](#extended-api)\r\n      - [toJSON()](#tojson)\r\n      - [VTTCue.fromJSON(json)](#vttcuefromjsonjson)\r\n      - [VTTCue.create(options)](#vttcuecreateoptions)\r\n  - [VTTRegion](#vttregion)\r\n    - [Extended API](#extended-api-1)\r\n        - [VTTRegion.fromJSON(json)](#vttregionfromjsonjson)\r\n        - [VTTRegion.create(options)](#vttregioncreateoptions)\r\n- [Browser](#browser)\r\n  - [Building Yourself](#building-yourself)\r\n  - [Bower](#bower)\r\n  - [Usage](#usage)\r\n- [Node](#node)\r\n  - [vtt.js](#vttjs-1)\r\n  - [node-vtt](#node-vtt)\r\n- [Tests](#tests)\r\n  - [Writing Tests](#writing-tests)\r\n  - [Cue2json](#cue2json)\r\n\r\nSpec Compliance\r\n===============\r\n\r\n- [Parsing](http://dev.w3.org/html5/webvtt/#webvtt-file-format-parsing) (Completed)\r\n  - [File](http://dev.w3.org/html5/webvtt/#webvtt-file-parsing) (Completed)\r\n  - [Region](http://dev.w3.org/html5/webvtt/#webvtt-region-settings-parsing) (Completed)\r\n  - [Cue Timings and Settings](http://dev.w3.org/html5/webvtt/#webvtt-cue-timings-and-settings-parsing) (Completed)\r\n  - [WebVTT Cue Text](http://dev.w3.org/html5/webvtt/#dfn-webvtt-cue-text-parsing-rules) (Completed)\r\n  - [Cue DOM Construction](http://dev.w3.org/html5/webvtt/#webvtt-cue-text-dom-construction-rules) (Completed)\r\n- [Rendering](http://dev.w3.org/html5/webvtt/#rendering) (In Progress)\r\n  - [Processing Model](http://dev.w3.org/html5/webvtt/#processing-model) (In Progress) ***No VTTRegion or vertical text support***\r\n    - [Apply WebVTT Cue Settings](http://dev.w3.org/html5/webvtt/#dfn-apply-webvtt-cue-settings) (In Progress)\r\n      - Steps 1 - 11 (Completed)\r\n      - Step 12 (In progress)\r\n  - [Applying CSS Properties](http://dev.w3.org/html5/webvtt/#applying-css-properties-to-webvtt-node-objects) (Completed)\r\n  - [CSS Extensions](http://dev.w3.org/html5/webvtt/#css-extensions) **(Won't Implement)**\r\n- [WebVTT API Shim](http://dev.w3.org/html5/webvtt/#webvtt-api-for-browsers) (Completed)\r\n  - [VTTCue](http://dev.w3.org/html5/webvtt/#vttcue-interface) (Completed) ***Shims the TextTrackCue interface as well***\r\n  - [VTTRegion](http://dev.w3.org/html5/webvtt/#vttregion-interface) (Completed)\r\n\r\n###Notes###\r\n\r\nOur processing model portion of the specification makes use of a custom property, `hasBeenReset`. It allows us to detect\r\nwhen a VTTCue is dirty, i.e. one of its properties that affects display has changed and so we need to recompute its display\r\nstate. This allows us to reuse a cue's display state if it has already been computed and nothing has changed to effect its\r\nposition.\r\n\r\nAPI\r\n===\r\n\r\n####WebVTT.Parser####\r\n\r\nThe parser has a simple API:\r\n\r\n```javascript\r\nvar parser = new WebVTT.Parser(window, stringDecoder);\r\nparser.onregion = function(region) {};\r\nparser.oncue = function(cue) {};\r\nparser.onflush = function() {};\r\nparser.onparsingerror = function(e) {};\r\nparser.parse(moreData);\r\nparser.parse(moreData);\r\nparser.flush();\r\n```\r\n\r\nThe Parser constructor is passed a window object with which it will create new\r\nVTTCues and VTTRegions as well as an optional StringDecoder object which\r\nit will use to decode the data that the `parse()` function receives. For ease of\r\nuse, a StringDecoder is provided via `WebVTT.StringDecoder()`. If a custom\r\nStringDecoder object is passed in it must support the API specified by the\r\n[#whatwg string encoding](http://encoding.spec.whatwg.org/#api) spec.\r\n\r\n####parse(data)####\r\n\r\nHands data in some format to the parser for parsing. The passed data format\r\nis expected to be decodable by the StringDecoder object that it has. The parser\r\ndecodes the data and reassembles partial data (streaming), even across line breaks.\r\n\r\n```javascript\r\nvar parser = new WebVTT.Parser(window, WebVTT.StringDecoder());\r\nparser.parse(\"WEBVTT\\n\\n\");\r\nparser.parse(\"00:32.500 --> 00:33.500 align:start size:50%\\n\");\r\nparser.parse(\"<v.loud Mary>That's awesome!\");\r\nparser.flush();\r\n```\r\n\r\n####flush()####\r\n\r\nIndicates that no more data is expected and will force the parser to parse any\r\nunparsed data that it may have. Will also trigger [onflush](#onflush).\r\n\r\n####onregion(region)####\r\n\r\nCallback that is invoked for every region that is correctly parsed. Returns a [VTTRegion](#http://dev.w3.org/html5/webvtt/#dfn-vttregion)\r\nobject.\r\n\r\n```js\r\nparser.onregion = function(region) {\r\n  console.log(region);\r\n};\r\n```\r\n\r\n####oncue(cue)####\r\n\r\nCallback that is invoked for every cue that is fully parsed. In case of streaming parsing oncue is\r\ndelayed until the cue has been completely received. Returns a [VTTCue](#http://dev.w3.org/html5/webvtt/#vttcue-interface) object.\r\n\r\n```js\r\nparser.oncue = function(cue) {\r\n  console.log(cue);\r\n};\r\n```\r\n\r\n####onflush()####\r\n\r\nIs invoked in response to `flush()` and after the content was parsed completely.\r\n\r\n```js\r\nparser.onflush = function() {\r\n  console.log(\"Flushed\");\r\n};\r\n```\r\n\r\n####onparsingerror(error)####\r\n\r\nIs invoked when a parsing error has occured. This means that some part of the\r\nWebVTT file markup is badly formed. See [ParsingError](#parsingerror) for more\r\ninformation.\r\n\r\n```js\r\nparser.onparsingerror = function(e) {\r\n  console.log(e);\r\n};\r\n```\r\n\r\n####WebVTT.convertCueToDOMTree(window, cuetext)####\r\n\r\nParses the cue text handed to it into a tree of DOM nodes that mirrors the internal WebVTT node structure of\r\nthe cue text. It uses the window object handed to it to construct new HTMLElements and returns a tree of DOM\r\nnodes attached to a top level div.\r\n\r\n```javascript\r\nvar div = WebVTT.convertCueToDOMTree(window, cuetext);\r\n```\r\n\r\n####WebVTT.processCues(window, cues, overlay)####\r\n\r\nConverts the cuetext of the cues passed to it to DOM trees&mdash;by calling convertCueToDOMTree&mdash;and\r\nthen runs the processing model steps of the WebVTT specification on the divs. The processing model applies the necessary\r\nCSS styles to the cue divs to prepare them for display on the web page. During this process the cue divs get added\r\nto a block level element (overlay). The overlay should be a part of the live DOM as the algorithm will use the\r\ncomputed styles (only of the divs to do overlap avoidance.\r\n\r\n```javascript\r\nvar divs = WebVTT.processCues(window, cues, overlay);\r\n```\r\n\r\n####ParsingError####\r\n\r\nA custom JS error object that is reported through the\r\n[onparsingerror](#onparsingerror) callback. It has a `name`, `code`, and\r\n`message` property, along with all the regular properties that come with a\r\nJavaScript error object.\r\n\r\n```json\r\n{\r\n  name: \"ParsingError\",\r\n  code: \"SomeCode\",\r\n  message: \"SomeMessage\"\r\n}\r\n```\r\n\r\nThere are two error codes that can be reported back currently:\r\n\r\n- 0 BadSignature\r\n- 1 BadTimeStamp\r\n\r\n**Note:** Exceptions other then `ParsingError` will be thrown and not reported.\r\n\r\n####VTTCue####\r\n\r\nA DOM shim for the VTTCue. See the [spec](http://dev.w3.org/html5/webvtt/#vttcue-interface)\r\nfor more information. Our VTTCue shim also includes properties of its abstract base class\r\n[TextTrackCue](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#texttrackcue).\r\n\r\n```js\r\nvar cue = new window.VTTCue(0, 1, \"I'm a cue.\");\r\n```\r\n\r\n**Note:** Since this polfyill doesn't implement the track specification directly the `onenter`\r\nand `onexit` events will do nothing and do not exist on this shim.\r\n\r\n####Extended API####\r\n\r\nThere is also an extended version of this shim that gives a few convenience methods\r\nfor converting back and forth between JSON and VTTCues. If you'd like to use these\r\nmethods then us `vttcue-extended.js` instead of `vttcue.js`. This isn't normally\r\nbuilt into the `vtt.js` distributable so you will have to build a custom distribution\r\ninstead of using bower.\r\n\r\n####toJSON()####\r\n\r\nConverts a cue to JSON.\r\n\r\n```js\r\nvar json = cue.toJSON();\r\n```\r\n\r\n####VTTCue.fromJSON(json)####\r\n\r\nCreate and initialize a VTTCue from JSON.\r\n\r\n```js\r\nvar cue = VTTCue.fromJSON(json);\r\n```\r\n\r\n####VTTCue.create(options)####\r\n\r\nInitializes a VTTCue from an options object where the properties in the option\r\nobjects are the same as the properties on the VTTCue.\r\n\r\n```js\r\nvar cue = VTTCue.create(options);\r\n```\r\n\r\n####VTTRegion####\r\n\r\nA DOM shim for the VTTRegion. See the [spec](http://dev.w3.org/html5/webvtt/#vttregion-interface)\r\nfor more information.\r\n\r\n```js\r\nvar region = new window.VTTRegion(0, 1, \"I'm a region.\");\r\ncue.region = region;\r\n```\r\n\r\n####Extended API####\r\n\r\nThere is also an extended version of this shim that gives a few convenience methods\r\nfor converting back and forth between JSON and VTTRegions. If you'd like to use these\r\nmethods then us `vttregion-extended.js` instead of `vttregion.js`. This isn't normally\r\nbuilt into the `vtt.js` distributable so you will have to build a custom distribution\r\ninstead of using bower.\r\n\r\n####VTTRegion.fromJSON(json)####\r\n\r\nCreates and initializes a VTTRegion from JSON.\r\n\r\n```js\r\nvar region = VTTRegion.fromJSON(json);\r\n```\r\n\r\n####VTTRegion.create(options)####\r\n\r\nCreates a VTTRegion from an options object where the properties on the options\r\nobject are the same as the properties on the VTTRegion.\r\n\r\n```js\r\nvar region = VTTRegion.create(options);\r\n```\r\n\r\nBrowser\r\n=======\r\n\r\nIn order to use the `vtt.js` in a browser, you need to get the built distribution of vtt.js. The distribution\r\ncontains polyfills for [TextDecoder](http://encoding.spec.whatwg.org/), [VTTCue](http://dev.w3.org/html5/webvtt/#vttcue-interface),\r\nand [VTTRegion](http://dev.w3.org/html5/webvtt/#vttregion-interface) since not all browsers currently\r\nsupport them.\r\n\r\n###Building Yourself###\r\n\r\nBuilding a browser-ready version of the library is done using `grunt` (if you haven't installed\r\n`grunt` globally, you can run it from `./node_modules/.bin/grunt` after running `npm install`):\r\n\r\n```bash\r\n$ grunt build\r\n$ Running \"update_submodules\" task\r\n\r\n$ Running \"uglify:dist\" (uglify) task\r\n$ File \"dist/vtt.min.js\" created.\r\n\r\n$ Running \"concat:dist\" (concat) task\r\n$ File \"dist/vtt.js\" created.\r\n\r\n$ Done, without errors.\r\n```\r\n\r\nYour newly built `vtt.js` now lives in `dist/vtt.min.js`, or alternatively, `dis/vtt.js` for an\r\nunminified version.\r\n\r\n###Bower###\r\n\r\nYou can also get the a prebuilt distribution from [Bower](http://bower.io/). Either run the shell\r\ncommand:\r\n\r\n```bash\r\n$ bower install vtt.js\r\n```\r\n\r\nOr include `vtt.js` as a dependency in your `bower.json` file. `vtt.js` should now\r\nlive in `bower_components/vtt.js/vtt.min.js`. There is also an unminified\r\nversion included with bower at `bower_components/vtt.js/vtt.js`.\r\n\r\n###Usage###\r\n\r\nTo use `vtt.js` you can just include the script on an HTML page like so:\r\n\r\n```html\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <title>vtt.js in the browser</title>\r\n  <script src=\"bower_components/vtt.js/vtt.min.js\"></script>\r\n</head>\r\n<body>\r\n  <script>\r\n    var vtt = \"WEBVTT\\n\\nID\\n00:00.000 --> 00:02.000\\nText\",\r\n        parser = new WebVTT.Parser(window, WebVTT.StringDecoder()),\r\n        cues = [],\r\n        regions = [];\r\n    parser.oncue = function(cue) {\r\n      cues.push(cue);\r\n    };\r\n    parser.onregion = function(region) {\r\n      regions.push(region);\r\n    }\r\n    parser.parse(vtt);\r\n    parser.flush();\r\n\r\n    var div = WebVTT.convertCueToDOMTree(window, cues[0].text);\r\n    var divs = WebVTT.processCues(window, cues, document.getElementById(\"overlay\"));\r\n  </script>\r\n  <div id=\"overlay\" style=\"position: relative; width: 300px; height: 150px\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\nNode\r\n====\r\n\r\nYou have a couple of options if you'd like to run the library from Node.\r\n\r\n###vtt.js###\r\n\r\n`vtt.js` is on npm. Just do:\r\n\r\n```\r\nnpm install vtt.js\r\n```\r\n\r\nRequire it and use it:\r\n\r\n```js\r\nvar vtt = require(\"vtt.js\"),\r\n    WebVTT = vtt.WebVTT,\r\n    VTTCue = vtt.VTTCue,\r\n    VTTRegion = vtt.VTTRegion;\r\n\r\nvar parser = new WebVTT.Parser(window);\r\nparser.parse();\r\n// etc\r\n\r\nvar elements = WebVTT.processCues(window, cues, overlay);\r\nvar element = WebVTT.convertCueToDOMTree(window, cuetext);\r\n\r\nvar cue = new VTTCue(0, 1, \"I'm a cue.\");\r\nvar region = new VTTRegion();\r\n```\r\n\r\nSee the [API](#api) for more information on how to use it.\r\n\r\n**Note:** If you use this method you will have to provide your own window object\r\nor a shim of one with the necessary functionality for either the parsing or processing\r\nportion of the spec. The only shims that are provided to you are `VTTCue` and `VTTRegion`\r\nwhich you can attach to your global that is passed into the various functions.\r\n\r\n###node-vtt###\r\n\r\nUse [node-vtt](https://github.com/mozilla/node-vtt). Node-vtt runs `vtt.js` on a PhantomJS page\r\nfrom Node so it has access to a full DOM and CSS layout engine which means you can run any part\r\nof the library you want. See the [node-vtt](https://github.com/mozilla/node-vtt) repo for more\r\ninformation.\r\n\r\nTests\r\n=====\r\n\r\nTests are written and run using [Mocha](http://visionmedia.github.io/mocha/) on node.js.\r\n\r\nTo run all the tests, do the following:\r\n\r\n```bash\r\n$ npm test\r\n```\r\n\r\nIf you want to run individual tests, you can install the [Mocha](http://visionmedia.github.io/mocha/) command-line\r\ntool globally, and then run tests per-directory:\r\n\r\n```bash\r\n$ npm install -g mocha\r\n$ cd tests/some/sub/dir\r\n$ mocha --reporter spec --timeout 200000\r\n```\r\n\r\nSee the [usage docs](http://visionmedia.github.io/mocha/#usage) for further usage info.\r\n\r\n###Writing Tests###\r\n\r\nTests are done by comparing live parsed output to a last-known-good JSON file. The JSON files\r\ncan be easily generated using `vtt.js`, so you don't need to write these by hand\r\n(see details below about [cue2json](#cue2json)).\r\n\r\n####TestRunner####\r\n\r\nThere's a prebuilt API in place for testing different parts of `vtt.js`. Simply\r\nrequire the [TestRunner](https://github.com/mozilla/vtt.js/blob/master/tests/test-runner.js)\r\nmodule in the `lib` directory and start writing tests using `mocha`. See an example of a test file\r\n[here](https://github.com/mozilla/vtt.js/blob/master/tests/cue-settings/align/test.js)\r\nwith its first test's WebVTT file [here](https://github.com/mozilla/vtt.js/blob/master/tests/cue-settings/align/bad-align.vtt)\r\nand its corresponding [parsing JSON file](https://github.com/mozilla/vtt.js/blob/master/tests/cue-settings/align/bad-align.json)\r\nand [processing JSON file](https://github.com/mozilla/vtt.js/blob/master/tests/cue-settings/align/bad-align-proc.json).\r\nYou can also check out the [tests](https://github.com/mozilla/vtt.js/tree/master/tests)\r\ndirectory for more examples on how to write tests.\r\n\r\n####jsonEqual(vttFile, jsonRefFile, message, onDone)####\r\n\r\nFirst parses the WebVTT file as UTF8 and compares it to the reference JSON file\r\nand then parses the WebVTT file as a string and compares it to the reference JSON\r\nfile.\r\n\r\n####jsonEqualStreaming(vttFile, jsonRefFile, message, onDone)####\r\n\r\nSimulates parsing the file while streaming by splitting the WebVTT file into\r\nchunks. Will simulate parsing like this `n` times for a single WebVTT file where\r\n`n` is the length in unicode characters of the file, so use this only on small\r\nfiles or else you will get a timeout failure on your test.\r\n\r\n####jsonEqualParsing(vttFile, jsonRefFile, message, onDone)####\r\n\r\nRuns `jsonEqual` and `jsonEqualStreaming` in one go.\r\n\r\n####jsonEqualProcModel(vttFile, jsonRefFile, message, onDone)####\r\n\r\nRuns the processing model over the `VTTCues` and `VTTRegions` that are returned\r\nfrom parsing the WebVTT file.\r\n\r\n####jsonEqualAll(vttFile, jsonRefFile, message, onDone)####\r\n\r\nRuns `jsonEqualParsing` and `jsonEqualProcModel`. Note that `jsonRefFile` should\r\ncontain JSON that is generated from parsing. The processing model test will compare\r\nits results to a JSON file located at `[vttFile]-proc.json`. Therefore, if you\r\nhave a WebVTT file named `basic.vtt` the JSON reference file for the processing\r\nmodel tests will be `basic-proc.json`.\r\n\r\n####jsonEqualAllNoStream(vttFile, jsonRefFile, message, onDone)####\r\n\r\nRuns `jsonEqual` and `jsonEqualProcModel` use this if you want to do parsing\r\nand processing tests, but do not want to simulate streaming because you\r\nhave too big of a WebVTT file.\r\n\r\n####Cue2json####\r\n\r\nYou can automatically generate a JSON file for a given `.vtt` file using `cue2json.js`.\r\nYou have a number of options for running `cue2json.js`.\r\n\r\n```\r\n$ grunt build\r\n$ Running \"uglify:dist\" (uglify) task\r\n$ File \"dist/vtt.min.js\" created.\r\n$ \r\n$ Done, without errors.\r\n$ ./bin/cue2json.js \r\n$ Generate JSON test files from a reference VTT file.\r\n$ Usage: node ./bin/cue2json.js [options]\r\n$ \r\n$ Options:\r\n$   -v, --vtt      Path to VTT file.                                                                                     \r\n$   -d, --dir      Path to test directory. Will recursively find all JSON files with matching VTT files and rewrite them.\r\n$   -c, --copy     Copies the VTT file to a JSON file with the same name.                                                \r\n$   -p, --process  Generate a JSON file of the output returned from the processing model. \r\n```\r\n\r\n**Note:** Cue2json will use the last built version of vtt.js so make sure to remember to rebuild it if you've made\r\nchanges to vtt.js since the last run.\r\n\r\n`$ ./bin/cue2json.js -v tests/foo/bar.vtt` print the JSON representation of the parsed output of the WebVTT file to console.\r\n\r\n`$ ./bin/cue2json.js -v tests/foo/bar.vtt -c` Same as above, but print the output to a JSON file with the name `tests/foo/bar.json`.\r\n\r\n`$ ./bin/cue2json.js -v tests/foo/bar.vtt > tests/foo/bar-bad.json` print JSON output to a file called `tests/foo/bar-bad.json`.\r\n\r\n`$ ./bin/cue2json.js -v tests/foo/bar.vtt -p` print JSON representation of running the processing model on the WebVTT file to console.\r\n\r\n`$ ./bin/cue2json.js -v tests/foo/bar.vtt -cp` Same as above, but print it to a file named `tests/foo/bar.json`.\r\n\r\n`$ ./bin/cue2json.js -d ./tests` walk the `tests` directory and rewrite any JSON files whose WebVTT source files are known i.e. there\r\nis a corresponding WebVTT file with the same name as the JSON file found.\r\n\r\n`$ ./bin/cue2json.js -d ./tests -p` Same as above, but print the JSON generated from running the processing model.\r\n\r\nAssuming the parser is able to correctly parse the vtt file(s), you now have the correct JSON to run\r\na JSON test.\r\n\r\n**NOTE:** Since `cue2json` uses the actual parser to generate these JSON files there is the possibility that\r\nthe generated JSON will contain bugs. Therefore, always check the generated JSON files to check that the\r\nparser actually parsed according to spec.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}